<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-theme.min.css">

    <style>
      body { padding: 1em; }
      h1 { color: blue; }
      .secret { color: red; }
      #tests {
        border-collapse: collapse;
      }
      #tests tr {
        border: 1px solid black;
      }
      #tests td {
        padding: 0.25em;
      }

      #tests td:nth-child(2) {
        border-left: 2px solid gray;
        width: 25%;
      }
      pre {
        border: 1px solid gray;
        padding: 1em;
        background-color: #fcfcfc;
      }

      .pass { background-color: #55FF55; }
      .fail { background-color: #FF5555; }

      blockquote {
        border: none;
        font-family: fantasy;
        font-style: italic;
      }

      .checkmark {
        color: green;
      }

      section *:not(h2):not(h3):not(a):not(code):not(h1):not(em):not(strong) {
        margin-left: 2em;
      }

      section h3 {
        margin-left: -2em;
      }

      .intro { font-style: italic; }
    </style>
  </head>
  <body>
    <section class="intro">
      <p>Part of a larger effort in thinking about ways to get benefits now that are <a href="https://github.com/w3c/webcomponents/wiki/Shadow-DOM:-Contentious-Bits">currently specified in Shadow DOM, but contentious</a> and held up.</p>
    </section>

    <section>
      <h1>Style-Mount</h1>
      <p>CSS works really well if you can follow strict patterns - it lets you define broad rules and inherit and override selectively, and it's pretty elegant.  On the other hand, in the real world, things are often not that simple.  We have legacy code bases, our ideas about the patterns to follow changes as we gain new powers or spend more time with the technology, we have large organizations or content management systems which attempt to mash together content developed by different teams at different times.  When it comes to these sorts of cases, CSS selectors are kind of like hand-grenades, it's a problem I described in <a href="https://briankardell.wordpress.com/2015/01/14/friendly-fire-the-fog-of-dom/">a recent post as the "friendly fire" problem</a>.  It's way too easy to do damage you didn't intend to do because it requires too much coordination of approach to get the right select/cascade/descend/inherit/specificity.  The more you mix it up, the more it gets to be like juggling chainsaws.  What you'd really like to do in these cases is isolate the various pieces so that the default thing is to do no harm, but the platform doesn't provide you an easy way to do that.... but can we fake it with what we have?</p>

      <h2>Thinking about how CSS works</h2>
      <p>All browsers come with a default, or "user-agent" stylesheet.  This is the thing that tells them how to display an element in the first place, and it does so with the same kinds of CSS rules that you and I write every day.  The design of CSS then is that it is a rules engine - all of the rules are loaded in order, they are stable sorted by "specifitity" - that is, each rule gets a weighted "score" according to the selector it is based on.  A "*" in the selector is worth 0 "points", a tag is worth 1, a class is worth an order of magnitude more (it's not specifically 10 based, but for illustration you can assume 10 points), an id is worth 100.  So the reason author CSS trumps the user-agent stylesheets is simply the user-agent stylesheet is very low specificity and it came first - authors will always be either more specific or have come later.  The problem now is that as you get to something deep into the page (say, a component developed by another team in your company) the specificity of the outside world is unknown - without intense cooperation, you can't know what you're inheriting, what to override or how to do it (because specificity).  Reasoning about this is hard.</p>

      <p>At some level though, you could imagine that what you really want to do is identify a container and say "Give me a clean slate (user-agent sheet) and let me automatically trump you within this container just like you trump the user agent!".  To some extent, we can kind of do this with a specificity strategy:  Imagine that I just had a copy of the user-agent stylesheet in which the rules had an artifically insanely high default specificity.  Well, we can do that too because the <code>:not()</code> pseudo-class counts the simple selector inside for its specificity.  So, if we created an attribute called, for example, <code>style-mount</code> and then picked an id which would be incredibly unlikely to exist in the while (say <code>#-_-</code>) when we could provide a clean slate which would work everywhere today by creating a default stylesheet with rules like <code>[style-mount] h1:not(#-_-):not(#-_-):not(#-_-) { <em>...</em> }</code> which has a specificity of 3 ids, 1 attribute and 1 tag (311 in base-10), enough to trump virtually any sane stylesheet's most ambitious selector.  Then, all you need is a way to 'hoist' more specific rules in somehow such that they follow the same pattern and you have essentially the same model as the page has with user-agent sheets!</p>

      <p>So here's a quick test <a href="https://github.com/bkardell/v-mount/blob/gh-pages/src/javascript/style-mount.js">style-mount.js</a> which does just that.  Including it will inject a reset sheet for any container (just once).  If you then identify a container with <code>CSS._specifyContainer(<em>containerElement</em>)</code> it will isolate it as described above and hoist any <code>&lt;style&gt;</code> tags within it to a more specific ruleset.  It has a couple of other methods too but they all are just alternate forms of this for a few ways I'm slicing up the problem - one that allows me to hoist a string of arbitrary cssText, another that I'm playing with in a larger custom element pattern.</p>

      <p>If you really really wanted to pierce through from the outside, you'd just have to make those rules _really_ specific - which you could use the same API above to manage, or just add another :not()</p>

      <p>The injection of rules happens just once, I dont think it is a big perf problem - you have exactly as many rules.  If you're worried about the complexity of the selectors slowing things down dramatically, I doubt it - browsers use a bloom filter and such cleverness that evaluating the same triple :not's on the same subject element should actually be very low cost.</p>
    </section>
  <body>
</html>